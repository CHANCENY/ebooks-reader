<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" xmlns:epub="http://www.idpf.org/2007/ops">
	<head>
		<title>B19491_07</title>
		<link href="css/style-JRserifv6.css" rel="stylesheet" type="text/css" />
	</head>
	<body id="B19491_07">
		<div id="_idContainer038">
			<h1 id="_idParaDest-107" class="chapter-number"><a id="_idTextAnchor186"></a>7</h1>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor187"></a>Maintaining Drupal</h1>
			<p><a id="_idTextAnchor188"></a>Every Drupal application requires maintenance. Those who adopt Drupal must understand common maintenance activities, including how to check for updates. Earlier chapters discussed code deployment workflows, environments, Composer, and more. This chapter brings these concepts together for a more comprehensive view of maintaining Drupal. This may propose practices that help automate the maintenance of Drupal new to some. Next, the book will discuss how to apply updates after the code is deployed. Finally, we share best practices when <span class="No-Break">performing updates.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Types <span class="No-Break">of maintenance</span></li>
				<li>Code <span class="No-Break">maintenance process</span></li>
				<li><span class="No-Break">Best practices</span></li>
			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor189"></a><a id="_idTextAnchor190"></a>Types of maintenance</h1>
			<p>Maintaining a<a id="_idIndexMarker215"></a> Drupal site can take many forms. Drupal itself is always evolving. Changes can be very frequent because they span releases in all projects of a Drupal application, including core and contributed projects. Releases can even happen based on project dependencies, so changes to Drupal application code can be very frequent. Drupal also runs on a platform stack with physical infrastructure built on software that also evolves. It is also common for content to require maintenance, such as when new staff is hired at a company and the staff listing is no longer up to date. Content management activities are covered in <a href="B19491_14.xhtml#_idTextAnchor419"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>. This chapter covers how to effectively maintain a <span class="No-Break">Drupal application.</span><a id="_idTextAnchor191"></a></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor192"></a>Code-related maintenance</h2>
			<p>Drupal <a id="_idIndexMarker216"></a>projects often put out new releases, and<a id="_idIndexMarker217"></a> those managing Drupal applications need a strategy for this. Releases can come in the form of major and minor releases. The semantics around major and minor are intentional. Major implies a significant architectural change without assumed backward compatibility. Minor assumes updates that may add features and fix bugs but maintain backward compatibility. It is often safe to assume minor updates can be loaded without something breaking. However, maintainers of projects are not perfect, and manual testing can be error-prone. Achieving a high percentage of coverage for automated tests requires significant, ongoing effort for complex projects. Don’t assume perfection even if it’s rare a minor update will <span class="No-Break">break things.</span></p>
			<p>Major updates often require investment. This is intentional. A major update signifies a major change. It also brings some discretion as a major version does not suggest the previous major version will not continue to have minor version updates. Application maintainers have discretion on what is maintained. Previous major versions may also have maintenance for some defined period to afford a longer upgrade window. An older major version may continue to get releases for bug fixes or routine maintenance for a period of time or even indefinitely. Application maintainers need to review each project and major release specific to their application. If <span class="No-Break">possible, upgrade.</span></p>
			<p>Drupal core has the most significance for major updates. Drupal applications harness other Drupal projects, as this is a major part of its extensibility value-add. Projects, much as with custom Drupal projects, are required to remediate any code deprecations found in major versions. Some community projects may not have yet been ported to the next version of Drupal. Application maintainers can submit patches to the community and help project maintainers with <span class="No-Break">this effort.</span></p>
			<p>Project updates also come in the form of routine updates and security updates. Routine updates are normal for bug fixes or requests from the community. Application maintainers have some discretion on when to apply these updates, but security updates are time-critical to ensure a Drupal application is not vulnerable to attack. Releases are sequential, and a security release can come at any time. As such, to address the security release, application maintainers may also have to install several routine updates if the application is <a id="_idIndexMarker218"></a>leveraging an earlier release of <span class="No-Break">a </span><span class="No-Break"><a id="_idIndexMarker219"></a></span><span class="No-Break">project.</span></p>
			<p>Themes can be another source of code-related maintenance. Some maintenance can be discretional based on how a developer builds a theme and which dependencies are used for development. Most Drupal applications have their custom theme. Themes have Drupal-related standards, such as Twig, CSS, libraries, and more, but there is no broader standard for other frontend technologies. It is common for frontend developers to use popular tools found in frontend communities to build themes in Drupal. Tools such as <strong class="source-inline">npm</strong> and the Node ecosystem can often be used to compile CSS, develop responsive functionality, and more. This is largely outside of Drupal and discretional for those working on themes. But, as Drupal, Node projects have their maintenance with releases, security <a id="_idIndexMarker220"></a>updates, and more. Given how common this <a id="_idIndexMarker221"></a>practice is, Drupal applications often have to maintain both Drupal- and <span class="No-Break">Node-related pro<a id="_idTextAnchor193"></a>jects.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor194"></a>Infrastructure platform maintenance</h2>
			<p>Platforms also evolve. Drupal <a id="_idIndexMarker222"></a>conventionally runs on a <a id="_idIndexMarker223"></a>LAMP stack. Linux, Apache, MySQL, and PHP all have their releases and are tightly coupled with Drupal’s platform requirements. Lower-end hosting providers commonly sell raw infrastructure with a high degree of discretion on what is configured and installed on the host. While the flexibility is good, this leaves a heavy burden on operators. Those managing their infrastructure would then subsequently be responsible for keeping each component of the LAMP stack maintained and in concert with Drupal’s major releases found in the application. Package managers, such as <strong class="source-inline">apt</strong> and <strong class="source-inline">yum</strong>, can help perform routine system updates, often with minimal downtime. However, maintainers must be mindful that system updates can sometimes alter configuration and restore specific services back to defaults. A manual review may be required to ensure security settings and usage-based configuration <span class="No-Break">are intact.</span></p>
			<p>In an ideal world, the infrastructure of a Drupal application can handle anything. However, this is rarely the case. Traffic spikes can flood logs, use up significant system resources, and expose bottlenecks. Often, this goes back to the infrastructure and platform running a <span class="No-Break">Drupal application.</span></p>
			<p>Storage is one potential but common bottleneck. Storage applies to both the web server and the database. The web server often manages Drupal’s code, file content, and logs. The database has its storage considerations. Effective platform oversight ensures that storage is managed. Storage goes up with heavy Drupal usage. Issues can happen suddenly, whereby storage can fill up quickly. Monitoring storage periodically is one way to mitigate risk. Affording Drupal adequate storage to grow can effectively afford time before <span class="No-Break">an outage.</span></p>
			<p>Finally, do not forget about SaaS products. Outages or planned maintenance of third-party SaaS products can impair Drupal applications. This is common with analytical tools, third-party search, or even the infrastructure <span class="No-Break">running Drupal.</span></p>
			<p>When <a id="_idIndexMarker224"></a>running a Drupal application, it is important to<a id="_idIndexMarker225"></a> understand what needs to be maintained. From the infrastructure to the code, each element of the stack is different but requires maintenance. Given the complexity of the Drupal application and the frequency of updates, the next section dives deep into the code <span class="No-Break">maintenance <a id="_idTextAnchor195"></a>process.</span></p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor196"></a>Code maintenance process</h1>
			<p>One of the <a id="_idIndexMarker226"></a>technical and more frequent types of maintenance is around code updates. The community is already making efforts to lessen the technical burden of code updates through the Automatic Updates initiative worked on throughout Drupal 10 and, hopefully, in preparation for<a id="_idTextAnchor197"></a> <span class="No-Break">Drupal 11.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor198"></a>Reviewing code management and deployment concepts</h2>
			<p>Earlier chapters covered <a id="_idIndexMarker227"></a>useful concepts when considering maintenance. A brief review of these concepts is important when considering <span class="No-Break">code maintenance.</span></p>
			<p><a href="B19491_06.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> covered the creation of a Drupal application through the Composer project template and common Composer commands. Every Drupal 10 application should have a corresponding and accurate <strong class="source-inline">composer.json</strong> and <strong class="source-inline">composer.lock</strong> file. Those files help understand what code is currently built in an application and which constraints the update logic should follow for <span class="No-Break">installed projects.</span></p>
			<p><a href="B19491_03.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> covered the concept of environments and code deployment workflows. Production environments should only have well-tested deployments promoted from non-production environments. Production content should be staged down and sanitized to lower environments to properly test a code deployment. Recall <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.4</em>, which shows a potential environment-based code <span class="No-Break">deployment workflow.</span></p>
			<p>Awareness and update checking was also covered in <a href="B19491_06.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>. Drupal natively offers an email notification of updates based on its routine update checking. This can be configured to send to an email address and on a specified cadence. Pending updates can also be seen on Drupal’s status page, with special attention afforded to security releases. The Drupal community also offers specific feeds for project updates, a Slack channel with releases, and Twitter accounts that publish tweets when security updates come out, and there is documentation on <a href="http://Drupal.org">Drupal.org</a>. Application maintainers can pick the best channel<a id="_idIndexMarker228"></a> that<a id="_idTextAnchor199"></a> <span class="No-Break">serves them.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor200"></a>Typical code maintenance process</h2>
			<p>Code <a id="_idIndexMarker229"></a>maintenance largely follows standard <a id="_idIndexMarker230"></a>code deployment procedures, but with specific code that is built <span class="No-Break">through Composer.</span></p>
			<p>It is best to prepare updates on a local environment to help resolve errors and perform initial testing. A local environment should be prepared with the latest code in Git and production content <span class="No-Break">staged down.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Staging down can be performed in automated ways by using Drush. Drush has a native Drush aliases feature that can be used to perform remote operations. This book routinely references the use of environments. Each environment for a Drupal application can have its alias. Application maintainers with access to the environment infrastructure can leverage SSH to execute commands remotely with Drush through aliases. An alias can be widely used for remote operations from code deployments, clearing of cache, <span class="No-Break">and more.</span></p>
			<p>The following example leverages a <strong class="source-inline">mydrupal</strong> bogus alias with a <strong class="source-inline">prod</strong> bogus environment that shows how to prepare a local system for <span class="No-Break">code updates:</span></p>
			<pre class="console">
$ cd my_directory
$ git fetch –all&#160;&#160;# pulls updates from remote repositories
$ git reset –hard upstream/main&#160;&#160;# resets local git to latest main branch
$ cd web # switch to Drupal root
$ drush @mydrupal.prod sql:dump &gt; prod.sql # export database locally
$ drush sql:drop # remove local database
$ drush sql:cli &lt; prod.sql # load prod database
$ rm prod.sql # removes export
$ drush config:import # imports config from code
$ drush cr # clears cache</pre>			<p>The result of the example effectively rebuilds a local system with the most recent production content and code pulled down from a <span class="No-Break">Git repository.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Drupal developers do not have to stage down file content. The Drupal community has created tools such <a id="_idIndexMarker231"></a>as <em class="italic">Stage File Proxy</em> that allow for files to be served remotely. Large Drupal applications can often have gigabytes of files. Allowing a local or non-production system to reference files from a production system can often save significant time and storage space from <span class="No-Break">manual synchronization.</span></p>
			<p>Once the<a id="_idIndexMarker232"></a> local environment is<a id="_idIndexMarker233"></a> prepared, it is time to perform code updates. It is best practice to review the <strong class="source-inline">composer.json</strong> file ahead of time to ensure the update logic is correct. The following example shows how to load updates <span class="No-Break">with Composer:</span></p>
			<pre class="console">
$ cd my_directory
$ composer update</pre>			<p>The following screenshot demonstrates a sample of output from the Composer <span class="No-Break"><strong class="source-inline">update</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B19491_07_1.jpg" alt="Figure 7.1 – Output of Composer’s update command" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Output of Composer’s update command</p>
			<p>The output of the Composer <strong class="source-inline">update</strong> command shows some useful information. First, it demonstrates which projects were updated and to which version. If projects were removed from the application’s <strong class="source-inline">composer.json</strong> file or any project dependencies were found in a project’s <strong class="source-inline">composer.json</strong> file, they would get removed from the code.. Finally, it updates the <strong class="source-inline">composer.lock</strong> file with the <span class="No-Break">updated versions.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Composer’s changelog can help identify a testing strategy. Some updates may only be dependencies and not the actual projects loaded in the Drupal application. Dependencies can be mapped back to their project by running the <strong class="source-inline">why</strong> command <span class="No-Break">in Composer.</span></p>
			<p>Now, it is time<a id="_idIndexMarker234"></a> to deploy the changes and<a id="_idIndexMarker235"></a> test the updated code on the local system. The following example shows how to leverage Drush to do <span class="No-Break">the deployment:</span></p>
			<pre class="console">
$ cd my_directory/web
$ drush updb&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# runs database updates
$ drush cr&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# clears cache
$ drush config:import # imports configuration
$ drush cr&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# another cache clear</pre>			<p>After Drush 10.3, a new command was added to consolidate the preceding commands and <span class="No-Break">standardize deployments:</span></p>
			<pre class="console">
$ cd my_directory/web
$ drush deploy&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# runs commands above</pre>			<p>Once testing has been performed, changes must be committed and pushed up to the Git repository. The following example creates a new branch, commits the code, and pushes the new branch to the remote <span class="No-Break">upstream repository:</span></p>
			<pre class="console">
$ cd my_directory
$ git checkout -b code-update&#160;&#160;&#160;&#160;&#160;# creates code update branch
$ git add *
$ git commit -a -m &quot;Code updates&quot;
$ git push upstream code-update</pre>			<p>The upstream<a id="_idIndexMarker236"></a> Git repository should <a id="_idIndexMarker237"></a>now have a new branch with the local <span class="No-Break">code changes.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Developers often do not push code directly to a main branch. Code review workflows often harness separate branches and features such as pull or merge requests. Pull or merge requests allow other developers to review the code, and these requests often work with <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) systems<a id="_idIndexMarker238"></a> that execute automated testing, code scanning, and more. This is a recommended gate before outright deploying code to <span class="No-Break">any environment.</span></p>
			<p>Effective code maintenance helps keep applications routinely up to date. Observing deployment best practices helps avoid issues and perfor<a id="_idTextAnchor201"></a>m <span class="No-Break">updates effectively.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor202"></a>Best practices</h1>
			<p>Maintaining Drupal has several best practices that can help promote efficacy<a id="_idTextAnchor203"></a> and <span class="No-Break">ease maintenance.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor204"></a>Backups</h2>
			<p>Before performing any <a id="_idIndexMarker239"></a>maintenance, ensure environments are effectively backed up. While the aforementioned Drush commands are capable of exporting databases or downloading files, backups are often offered by platform hosting providers. Some providers have policies to perform automated backups periodically. Doing so can help ensure quick and effective restoration should there be <span class="No-Break">an issue.</span></p>
			<p>Restoring Drupal can be performed with a series of commands. Releases of a specific Drupal application often correspond to tags in Git. As an example, suppose there was an issue with the deployment of the application’s 1.1.20 release. The following example restores Git tag 1.1.19 and loads the database from a <span class="No-Break"><strong class="source-inline">backup.sql</strong></span><span class="No-Break"> file:</span></p>
			<pre class="console">
$ cd my_directory
$ git fetch –all
$ git reset –hard 1.1.19
$ cd web
$ ../vendor/bin/drush sql:cli &lt; backup.sql
$<a id="_idTextAnchor205"></a> ../vendor/bin/drush cr</pre>			<p>The example reverts the code to an earlier release and restores the database backup. A complete restore may also include file content, which can happen through the sele<a id="_idTextAnchor206"></a>cted <span class="No-Break">hosting platform.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor207"></a>Environment differences</h2>
			<p>Code deployments are not the <a id="_idIndexMarker240"></a>same across environments. Production environments do not have database or file imports. Performing an import would be destructive and effectively remove the live production content when it should be pristine. The following example is an altered code deployment process for production that releases a 1.1.20 release and does not include altering <span class="No-Break">the database:</span></p>
			<pre class="console">
$ cd my_directory
$ git fetch –all
$ git reset –hard 1.1.20
$ cd web
$ ../vendor/bin/drush deploy</pre>			<p>The example <a id="_idIndexMarker241"></a>releases code in a production environment but differs from non-production environments which must stage down content <span class="No-Break">from production.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Drupal configuration can change per environment. As a basic example, it is common to uninstall UI-based modules, such as Views UI, on production systems. Drupal maintains enabled extensions through its <strong class="source-inline">core.extensions.yml</strong> configuration. Leverage Drupal’s Configuration <span class="No-Break">Split module.</span></p>
			<p class="callout">A split represents any logical category of configuration. Configuration often resides in a standard configuration directory and is synchronized to the database. Each split has its directory with overridden or added configuration. It is common for production environments to have their configuration split with only specific <span class="No-Break">production configurations.</span></p>
			<p class="callout">There are Drush commands for Configuration Split import that can be run during deployments on specific environments. Drush commands also exist for config split export to help generate configuration <span class="No-Break">in splits.</span></p>
			<p class="callout">While every split adds maintenance overhead in ensuring configuration updates apply to every split, this allows for any environment, including local, to main<a id="_idTextAnchor208"></a>tain <span class="No-Break">its configuration.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor209"></a>Managed platforms</h2>
			<p>Several vendors sell managed <a id="_idIndexMarker242"></a>platforms for Drupal. Many offer environments and native code deployment tooling that helps stage up code and stage down content. Each vendor offers different features that can help save time, perform automation, and more. This book does not offer any opinions or bias toward managed platforms, just that they often aim to reduce maintenance-related needs for <span class="No-Break">Drupal applications.</span></p>
			<p>One primary benefit of managed platforms is platform-level updates. Their products often offer and automate the upgrades of platform services, such as PHP, MySQL, and the underlying operating system. Also, the infrastructure is managed. This can help application maintainers just<a id="_idTextAnchor210"></a> focus on <span class="No-Break">the application.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor211"></a>SaaS services</h2>
			<p>It is very common for developers to<a id="_idIndexMarker243"></a> leverage SaaS services. For Git, both GitHub and GitLab are popular managed Git services. Both offer CI tools that can invoke automated testing or even run Composer commands to build the code base. Managed Git services also offer dependency checkers capable of submitting pull or merge requests for updates. This is a helpful way to automate theme-level Node dependencies in a Drupal application. Tools such as Violinist (<a href="https://violinist.io/">https://violinist.io/</a>) can work with a<a id="_idIndexMarker244"></a> managed Git offering to check a <strong class="source-inline">composer.lock</strong> file for Drupal-related updates and submit pull or merge requests with the updates. Such services help discover and submit code<a id="_idTextAnchor212"></a> changes <span class="No-Break">relatively easily.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor213"></a>Update frequency</h2>
			<p>Performing routine updates over <a id="_idIndexMarker245"></a>“ time helps stay on top of releases. All of the ease-of-use recommendations previously mentioned can help both find and release smaller changes more frequently. Performing smaller releases means it’s easier to identify breaking changes with less to roll back and generally helps perform more <span class="No-Break">targeted testing.</span></p>
			<p>Security updates need to be <a id="_idTextAnchor214"></a>applied as soon <span class="No-Break">as possible.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor215"></a>Product life cycles</h2>
			<p>Understanding product life cycles<a id="_idIndexMarker246"></a> can help plan ahead. Drupal often publishes its major and minor releases, including its end-of-life events. The same can be said for Symfony-, PHP-, MySQL-, and Node-based projects. Major and minor releases are often planned and published well in advance. Security updates, however, c<a id="_idTextAnchor216"></a>an come at any point <span class="No-Break">in time.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor217"></a>System monitoring and tools</h2>
			<p>For those not using a managed service, consider <a id="_idIndexMarker247"></a>leveraging system alerting and thresholds. No one wants to get paged in the middle of the night to swap storage that fills up or address a server that goes down. System alerts can help proactively raise awareness when an issue may be looming. As an example, proactive alerts can be sent if CPU usage peaks, storage is rising at an unreasonable pace, or storage crosses a desired threshold. Addressing potential issues before they become issues helps offer higher-quality service and <span class="No-Break">avoids outages.</span></p>
			<p>Log rotation is a common way to manage Drupal storage. Heavy-traffic Drupal applications can generate a lot of logs. Log retention policies that rotate, move older logs to other storage, and prune active storage help manage one of the biggest risks to storage. Managed enterprise logging capabilities can also be integrated and then offload logging <a id="_idTextAnchor218"></a>from system <span class="No-Break">storage altogether.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor219"></a>Edge systems</h2>
			<p>Enterprise Drupal<a id="_idIndexMarker248"></a> applications<a id="_idIndexMarker249"></a> commonly leverage a <strong class="bold">content delivery network </strong>(<strong class="bold">CDN</strong>) as a <strong class="bold">web application firewall</strong> (<strong class="bold">WAF</strong>). This has both performance and security benefits. CDNs often<a id="_idIndexMarker250"></a> easily integrate with Drupal’s native caching system to minimize direct web requests to the running Drupal hosting platform. Direct requests can be scanned and rejected if the request mimics an attack on the Drupal application. For maintenance and outages, CDNs can often serve a cached version of Drupal while updates run. This is helpful for end-user continuity even if an outage or a maintenance event is happening on the backend <span class="No-Break">of Drupal.</span></p>
			<p>Harnessing best practices helps Drupal developers learn from the experience of others to effectively maintain Drupal. Leveraging backups, maintaining different environments for code deployment, and leveraging third-party services such as managed platforms and edge systems<a id="_idIndexMarker251"></a> all help mitigate risks of code deployments common with Drupal maintenance. Maintaining awareness of life cycles helps with planning, and effective monitoring provides transparency into how maint<a id="_idTextAnchor220"></a>enance runs on <span class="No-Break">your infrastructure.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor221"></a>Summary</h1>
			<p>Successful Drupal practitioners know how to effectively maintain Drupal applications. Performing maintenance with best practices and doing so routinely helps ensure Drupal applications continue to run well, are secure, and get the benefit of ongoing features and fixes furnished by the community. Applications must run on a well-maintained platform as well, which includes updates to PHP, MySQL, and operating systems. Maintenance of Drupal requires an effective code deployment strategy and an understanding of all parts of Drupal’s architecture (code, content, files, and configuration). Leveraging tools such as Composer and Drush provides code-base management and helps to perform automation. Finally, best practices exist by reviewing product life cycles, having backup strategies, harnessing managed services for hosting, Git, CDN, and update checkers, and adhering to environment-level differences. The next chapter explores Drupal features around content structures and <span class="No-Break">language-level support.</span></p>
		</div>
	</body>
</html>
