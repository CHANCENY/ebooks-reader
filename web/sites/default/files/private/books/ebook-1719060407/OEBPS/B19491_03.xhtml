<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" xmlns:epub="http://www.idpf.org/2007/ops">
	<head>
		<title>B19491_03</title>
		<link href="css/style-JRserifv6.css" rel="stylesheet" type="text/css" />
	</head>
	<body id="B19491_03">
		<div id="_idContainer016">
			<h1 id="_idParaDest-43" class="chapter-number"><a id="_idTextAnchor060"></a>3</h1>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor061"></a>Infrastructure and Overview of Technical Architecture</h1>
			<p><a id="_idTextAnchor062"></a><a id="_idTextAnchor063"></a>This chapter focuses on many technical aspects of Drupal. It begins by covering the required infrastructure to host Drupal applications. Then, the three primary components of Drupal’s application architecture are reviewed. After that, Drupal’s code architecture is explored from both the backend and the frontend, covering the programming languages, tools, and practices used to develop Drupal. The chapter concludes with a high-level overview of how to effectively maintain a Drupal site and perform standard operations, such as <span class="No-Break">code updates.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Hosting Drupal and <span class="No-Break">platform requirements</span></li>
				<li><span class="No-Break">Drupal architecture</span></li>
				<li>Drupal management <span class="No-Break">and operations</span></li>
			</ul>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor064"></a><a id="_idTextAnchor065"></a>Hosting Drupal and platform requirements</h1>
			<p>Drupal requires a <a id="_idIndexMarker057"></a>hosted platform to run any Drupal application. Drupal runs as a server-side rendered PHP application accessible from a web browser. The hosting platform must be able to process requests made through its web server to execute the Drupal application. Drupal is not stateless. To be able to make configurations and store content, Drupal requires the hosting platform to persistently store files and structured content in a database. The context of each request helps the application determine how to process the request. Drupal loads its configuration, queries relevant information from the database, and leverages PHP to do <span class="No-Break">the processing.</span></p>
			<p>The following figure shows an <a id="_idIndexMarker058"></a>example <strong class="bold">LAMP</strong> (<strong class="bold">Linux, Apache, MySQL, and PHP</strong>) stack with a <span class="No-Break">Drupal application:</span></p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B19491_03_1.jpg" alt="Figure 3.1 – High-level LAMP stack and request flow" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – High-level LAMP stack and request flow</p>
			<p>Each version of <a id="_idIndexMarker059"></a>Drupal sets its own platform requirements. Platform requirements are published on <strong class="source-inline">drupal.org</strong> and are updated upon the release of each major version. They often correlate with planned releases of dependent projects and are communicated well in advance of new Drupal releases. At a high level, Drupal observes semantic versioning that follows a convention of major, minor, and patch versions. This is formatted as <strong class="source-inline">major.minor.patch</strong> and has explicit definitions. With major versions, it is important to consider platform requirements given that they span developers working on their systems, code deployments, and more. Platform requirements span web servers, database servers, supported programming languages, enabling libraries, and system configuration. Details on the servers and their purpose are covered in the next section of <span class="No-Break">this chapter.</span></p>
			<p>The platform should not be viewed as static. The underlying platform must evolve as Drupal evolves. While<a id="_idIndexMarker060"></a> Drupal is built on PHP and comprises a lot of the code in Drupal’s application, each PHP version introduces new programming language conventions and the deprecation of old ones. It cannot be assumed that a hosting environment will just work if it is not running Drupal’s specified version of PHP. This is especially important when upgrading Drupal applications. Major versions of Drupal update platform requirements that commonly include the latest stable version of PHP at the time of the major release. This practice is in line with dependent projects, such as Symfony, which require Drupal to foundationally run its application. Drupal’s dependencies are detailed in the <span class="No-Break">next sectio<a id="_idTextAnchor066"></a>n.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor067"></a>Drupal architecture</h1>
			<p>Drupal’s architecture is both broad <a id="_idIndexMarker061"></a>and deep; there are many technical aspects of Drupal, and each typically requires some level of specialized knowledge to understand. It starts with the infrastructure that runs the Drupal application, which has a specific stack and knowledge of system administration. The application itself has three main architectural components, which are detailed shortly. The most complex is code. Backend development and frontend development leverage different programming languages and best practices. This section will not provide a deep dive into any specific subject matter, but rather an overview of high-level knowledge for all <span class="No-Break">of Drup<a id="_idTextAnchor068"></a>al.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor069"></a>Infrastructure technical stack</h2>
			<p>Drupal spans many layers of a<a id="_idIndexMarker062"></a> technical stack, as shown by its<a id="_idIndexMarker063"></a> platform requirements. Drupal is an application that is commonly associated with the LAMP stack. At the lowest level, Drupal dependencies run on operating systems. Given the free and open-source nature of Drupal, Linux is the most common operating system. It offers administrators a more polished and documented experience for running Drupal. While it is technically possible to use Windows, this is less common and may result in unexpected <span class="No-Break">edge cases.</span></p>
			<p>On top of the operating system runs various servers and capabilities, including the web server, PHP, and database server. Apache is a widely adopted web server, but alternatives, such as Nginx, can be used effectively. PHP is installed on the system and also integrated with the web server through various mechanisms (normally Apache mods or PHP FPM). MySQL and Percona (a variation of MySQL) are common database options, but Drupal offers support for PostgreSQL and other databases. Pay careful attention to system firewalls that may block traffic between services or not allow a public interface to the <span class="No-Break">web server.</span></p>
			<p>At the top of the stack is the end user’s browser, which Drupal defines as explicit browser and version support. This is most common for Drupal’s frontend given that browsers have different support for features in CSS and Drupal’s commitment to accessibility. This was shown previously in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></p>
			<p>With any <a id="_idIndexMarker064"></a>technical infrastructure, each<a id="_idIndexMarker065"></a> component has its own maintenance needs. As an example, PHP routinely releases new versions. A major version release adds new functionality and deprecates the old. Upgrading even one component in the infrastructure requires it to correspond to the version of the Drupal application and its platform requirements. Note that each infrastructure component has a specific configuration (MySQL and PHP in settings), extensions (PHP and Apache mods), and options that need to be set up to effectively run Drupal. Specifics can be found on <strong class="source-inline">drupal.org</strong> and are detailed in the release notes of each <span class="No-Break">major v<a id="_idTextAnchor070"></a>ersion.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor071"></a>Application architecture</h2>
			<p>Drupal’s<a id="_idIndexMarker066"></a> application architecture<a id="_idIndexMarker067"></a> has three <span class="No-Break">primary components:</span></p>
			<ul>
				<li><strong class="bold">Code</strong>: The files<a id="_idIndexMarker068"></a> that define Drupal’s application executed by <span class="No-Break">the server</span></li>
				<li><strong class="bold">Database</strong>: Persistent <a id="_idIndexMarker069"></a>structured data for Drupal’s content, configuration, <span class="No-Break">and more</span></li>
				<li><strong class="bold">Files</strong>: Assets, such as <a id="_idIndexMarker070"></a>images or documents, that are stored on the <span class="No-Break">server’s filesystem</span></li>
			</ul>
			<p>Starting with<a id="_idIndexMarker071"></a> Drupal 8, a fourth component for the configuration was established. However, the configuration is built upon the three primary components, as configuration files are most often versioned with the code but can optionally be stored in files. The three primary components must be in sync with one another for the Drupal <a id="_idIndexMarker072"></a>application to maintain parity. It is incredibly important to understand the purpose and value of <span class="No-Break">each component.</span></p>
			<p>The code runs the Drupal application and maintains the connection to the database and file components. It is also responsible for exporting, importing, and synchronizing the configuration between the code/files and the database. Code is often versioned in a code versioning system (usually Git), so it has a persistent log of changes (commits) and tags for releases. Both the database and file components maintain persistent content. The database stores the structured content and state of the Drupal application using a history called schema versions. Both core and Drupal projects maintain a record of schema versions within code that can afford changes to the database defined within the code updates. The file’s component is responsible for content-based file assets, such as a JPEG image managed by Drupal’s media system or a PDF file attached to a Drupal node. All of the metadata for the file assets are stored in the database with the <span class="No-Break">content itself.</span></p>
			<p>The following figure shows a request being made to Drupal that has code deployed <span class="No-Break">from Git:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B19491_03_2.jpg" alt="Figure 3.2 – LAMP stack with a cloned Drupal application" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – LAMP stack with a cloned Drupal application</p>
			<p>Drupal <a id="_idIndexMarker073"></a>harnesses projects for its modular architecture. As previously mentioned, Drupal resembles building blocks. Some applications may want some projects enabled, while others may not. Drupal affords four types of projects: core, modules, themes, and distributions. As of now, Drupal only has one core project, but it overlaps with project <a id="_idIndexMarker074"></a>contribution processes on <strong class="source-inline">drupal.org</strong>. Modules are changes to Drupal’s backend application that add new features or extend existing features of Drupal’s subsystems. Themes extend Drupal’s frontend application. Both modules and themes are stored in code and have static metadata in YAML that allow Drupal to effectively articulate what is in the project and what its basic Drupal settings are. Distributions offer opinionated starting points that integrate into Drupal’s installation process. A distribution defines its corresponding modules, themes, and default configuration to allow a brand-new Drupal application to have specific features and configurations set up during installation. It is unclear whether distributions will exist beyond Drupal 10, as a new feature<a id="_idIndexMarker075"></a> called <strong class="bold">recipes</strong> will be built in Drupal 10. The primary benefit of recipes is that distributions complicate code updates because the entire distribution must be maintained as a whole. Recipes allow for one-time installation without the maintenance burden of a distribution. A recipe <a id="_idIndexMarker076"></a>can also be installed at any point in the lifecycle of a Drupal application. More details on recipes can be found in the <em class="italic">What’s new in Drupal 10?</em> secti<a id="_idTextAnchor072"></a>on of <a href="B19491_04.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor073"></a>Backend architecture</h2>
			<p>Drupal’s backend code architecture is a<a id="_idIndexMarker077"></a> combination of standard projects in the PHP ecosystem (akin to upstream projects) and its code built on top of the projects. This was a significant difference between Drupal 7 and Drupal 8. The Drupal community<a id="_idIndexMarker078"></a> claimed the new architecture <em class="italic">got off of the island</em>, meaning it adopted more modern PHP development practices that harnessed and contributed to a broad ecosystem of PHP projects in favor of implementing application-specific solutions that other projects already solved. Upstream projects are stable, well-tested, highly adopted, and integrated by countless projects outside of Drupal. To realize this benefit, Drupal needed to support Composer (<strong class="source-inline">getcomposer.org</strong>) to have thoughtful dependency management for its code and dependencies in the PHP community. The adoption of Symfony components was one notable change that helped Drupal adopt PSR standards and leverage widely adopted capabilities such as Symfony’s HTTP kernel, filesystem, routing, and dependency injection. Drupal then proceeded to build subsystems and features, such as modules, media, and logging, on top of the foundational components pulled from the upstream ecosystem. Drupal core is delivered with a <strong class="source-inline">composer.json</strong> file<a id="_idIndexMarker079"></a> that defines the foundational components, but Drupal projects can have their <strong class="source-inline">composer.json</strong> file to bring in other PHP libraries from the upstream community. A drupal core often still abstracts the use of specific libraries or projects through its APIs to minimize reliance on specific projects and to abstract supported capabilities through Drupal’s framework. Should another project be better in the future, Drupal can readily adopt it while not breaking backward compatibility in its framework. It is strongly recommended to use Drupal’s provided framework within custom and contributed code for <span class="No-Break">these reasons.</span></p>
			<p>The following figure shows the code workflow, from cloning code in Git, through building code in Composer, to deploying built code on a <span class="No-Break">web server:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B19491_03_3.jpg" alt="Figure 3.3 – Drupal code deployment workflow" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Drupal code deployment workflow</p>
			<p>Modules have a specific composition. Basic metadata, such as the project name, category, and dependencies, is stored in a <strong class="source-inline">[module-name].info.yml</strong> file. Various other YAML files exist for registering services and managing libraries. A <strong class="source-inline">composer.json</strong> file also exists with packaging metadata and dependencies on both <strong class="source-inline">drupal.org</strong> and the broader PHP ecosystem. Historical <em class="italic">hook-based</em> code, introduced in earlier versions of Drupal, is found in the <strong class="source-inline">[module-name].module</strong> file. However, PSR <a id="_idIndexMarker080"></a>standards were introduced that use new <a id="_idIndexMarker081"></a>object-oriented conventions aligned with the Symfony projects Drupal depends on. Under the <strong class="source-inline">src</strong> directory, a series of subdirectories and PHP classes exist that the underlying systems automatically register and process. Under the <strong class="source-inline">tests</strong> directory is where all PHPUnit tests exist, tied to a specific module’s functionality. Finally, schema versions are managed with a <strong class="source-inline">[module-name].install</strong> file. Modules may also deliver submodules, commonly found in the <strong class="source-inline">modules</strong> directory. This pattern is used for tightly coupled, optional capabilities for the <span class="No-Break">base module.</span></p>
			<p>Automated testing is another critical aspect of Drupal’s code architecture. Drupal core delivers various types of tests built off of the PHPUnit framework: unit, kernel, functional, browser, and functional JavaScript. Each type of test is intended to cover different test cases found within module or theme projects and is well documented on <strong class="source-inline">drupal.org</strong>. Drupal also leverages the backstage project for the frontend testing framework. Effective Drupal projects harness automated testing for predictable and reliable changes to code. In fact, Drupal core has a gated process that requires test changes and passing tests before committing a change. Great community contributions and effective project maintainership can often be measured by the existence of tests. Tests can also be <a id="_idIndexMarker082"></a>created for custom Drupal projects. A <a id="_idIndexMarker083"></a>high-quality and change-friendly Drupal application has high test coverage for both contr<a id="_idTextAnchor074"></a>ibuted and <span class="No-Break">custom code.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor075"></a>Frontend architecture</h2>
			<p>While Drupal’s backend manages the<a id="_idIndexMarker084"></a> foundational application, Drupal has<a id="_idIndexMarker085"></a> a robust frontend architecture as well. Drupal’s frontend architecture spans CSS, JavaScript, and HTML markup. Drupal leverages themes for the frontend. Themes can be built for delivering Drupal content or for styling Drupal’s administration system (often referred to as <em class="italic">themes</em> and <em class="italic">admin themes</em>). Out of the box, Drupal core delivers <span class="No-Break">several themes:</span></p>
			<ul>
				<li><strong class="bold">Claro</strong>: The <a id="_idIndexMarker086"></a>default <span class="No-Break">admin theme</span></li>
				<li><strong class="bold">Olivero</strong>: The<a id="_idIndexMarker087"></a> <span class="No-Break">default theme</span></li>
				<li><strong class="bold">Stark</strong>: A theme <a id="_idIndexMarker088"></a>with minimal styling and features commonly used <span class="No-Break">for debugging</span></li>
				<li><strong class="bold">Starter Kit</strong>: A theme <a id="_idIndexMarker089"></a>used as a launch point for custom <span class="No-Break">Drupal theming</span></li>
			</ul>
			<p>Both Claro and Olivero were deemed stable shortly before the release of Drupal 10, replacing Bartik and Seven found in earlier versions. Starter Kit is a unique type of theme, as it offers a framework for creating default custom themes from a defined starting point and has a command-line tool to create new themes from a starter kit. This is a useful feature when you want an opinionated starting point for a theme but need to perform specific customization for one or more <span class="No-Break">Drupal sites.</span></p>
			<p>The following command creates a new theme from the <span class="No-Break">default StarterKit:</span></p>
			<pre class="console">
$ php core/scripts/drupal generate-theme my_new_theme</pre>			<p>Themes<a id="_idIndexMarker090"></a> have a specific architectural composition. First, a theme has various metadata defined as YAML in an <strong class="source-inline">info.yml</strong> file. Common settings, such as name and category, exist. Other settings register Twig templates/CSS files, project dependencies, logo, supported core versions, and registered regions that the theme provides. Libraries are defined in a <strong class="source-inline">libraries.yml</strong> file to give instructions on what CSS or JavaScript libraries need to be loaded in the Drupal application for the theme to work properly. A theme <a id="_idIndexMarker091"></a>can also provide a base theme setting for a theme to only provide overrides from an inherited theme. A theme also contains directories for Twig templates to render HTML markup and is commonly used to organize CSS and JavaScript files (assumed to be generated given that Drupal does not have an opinionated CSS generation tool). Twig files follow specific naming conventions that expose templates to themes for specific Drupal features, such as blocks, views, and node-based templates. All out-of-the-box Drupal themes maintain explicit support for browsers as per the policies defined at <strong class="source-inline">drupal.org</strong>. Developers that use out-of-the-box themes as base themes should be mindful of the policy tied to<a id="_idIndexMarker092"></a> each major version of Drupal, as there may be unintended consequences supporting<a id="_idIndexMarker093"></a> certain browsers or versions of a browser (such as older versions of <span class="No-Break">Internet Explorer).</span></p>
			<p>This section reviewed the infrastructure required to run Drupal and Drupal’s application architecture. It is critically important to know what is required to run Drupal and to be aware of Drupal’s backend and frontend aspects when creating applications. The modularity of Drupal affords developers flexibility in enabling or disabling features based on the use cases required for the application. Understanding the technology behind Drupal helps developers with training, making open-source contributions, and understanding Drupal’s approa<a id="_idTextAnchor076"></a>ch to solving <span class="No-Break">specific problems.</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor077"></a>Drupal management and operations</h1>
			<p>Often people joke that Drupal is free “like a puppy.” While the software is made available for free through the open-source community, it takes work to build your application and subsequently maintain and operate it. It can be as basic as performing routine code updates, or it may involve complex concepts, such as staged code workflows and automated deployment processes. This section provides approaches and considerations for maintenance and opera<a id="_idTextAnchor078"></a>tions for a <span class="No-Break">Drupal application.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor079"></a>Maintenance</h2>
			<p>Drupal runs at the <a id="_idIndexMarker094"></a>top of a technology stack, but thoughtful maintenance includes keeping the full stack up to date. Updates apply at all levels of <a id="_idIndexMarker095"></a>the <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>), packages running on the OS, the web server, the database server, and more. PHP commonly runs as a package of the OS and is configured on the web server. Any update in the stack can introduce new or updated configurations that should be carefully managed because they may not be supported by the Drupal application. PHP updates can directly impair Drupal’s application code if left unmanaged. While many of the projects found in a LAMP stack have mature update processes and routine maintenance rarely breaks Drupal, it is important to note that a thoughtful maintenance strategy should at least have measures in place to upgrade and test safely. There is also value in using <span class="No-Break">established tools.</span></p>
			<p>Adopters need to consider maintenance for Drupal as well. The most notable is code updates. Drupal only offers support for specific major and minor versions of Drupal core. Doing more would put a substantial burden on a community largely made up of volunteers who maintain the software. This policy includes supported versions of Drupal’s dependencies, such as Symfony projects. The most notable impact of supported versions is a policy tied to security releases. Drupal will only offer security coverage for code that falls within the supported versions. It is prudent to keep code running on a Drupal application up to date. Given that a security update can come at any time and during any project that an application adopts, it is best practice to update your application when releases come out. Making a larger number of releases within a code update has a higher risk of introducing unintended changes or bugs that require adequate time to test against the specific capabilities of your application. Security updates should be applied in a timely fashion to mitigate the risk of your application getting compromised. Keeping an application up to date when a security release comes out provides more confidence that a smaller change will not break a Drupal application. The Drupal Steward service offered by the Drupal Association is a web application firewall that protects your application from malicious requests. Any request that attempts to exploit a vulnerability is filtered by the firewall. This can save you time and lower the urgency of performing <span class="No-Break">security updates.</span></p>
			<p>Drupal also has a <a id="_idIndexMarker096"></a>deprecation policy where minor versions will mark deprecations that get removed from the next major release. It is best practice for applications to remediate deprecations when they become known in minor versions as opposed to when they get delivered by major releases. Application developers need to pay close attention to deprecations found in custom projects, but developers have an opportunity to contribute deprecation remediation back to projects on <strong class="source-inline">drupal.org</strong>. This can help make progress for projects that an application may depend on upstream on <strong class="source-inline">drupal.org</strong>. Be mindful that custom code may leverage deprecated capabilities in PHP that may also <span class="No-Break">need remediation.</span></p>
			<p>Drupal code updates <a id="_idIndexMarker097"></a>may also drive changes to the stack. As mentioned, major versions of Drupal have defined platform requirements. When upgrading, it is implied that the platform requirements are in place, including versions of PHP<a id="_idTextAnchor080"></a>, database servers, and <span class="No-Break">web servers.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor081"></a>Operations</h2>
			<p>This<a id="_idIndexMarker098"></a> section covers what is required for the effective operation of a Drupal application. Heavy emphasis is placed on keeping Drupal code up to date and employing practices that help deploy code responsibly. Best practices harness DevOps philosophies, which emphasize the automation of processes over <span class="No-Break">manual efforts.</span></p>
			<p>We start with the concept of a deployment. A deployment<a id="_idIndexMarker099"></a> is the act of updating code on the servers that execute the code. It is highly recommended to update code early and frequently because a deployment creates a change. The smaller the change deployed, the easier it is to ensure that the deployment is successful. In Drupal, the code provided by the community is updated all the time. It can be as simple as a contributed module addressing a bug or a minor update to Drupal core. Alternatively, it can be far more significant, such as a major Drupal version update that has deprecations or a new major version of a module that may break the API for other modules that depend <span class="No-Break">on it.</span></p>
			<p>Environments<a id="_idIndexMarker100"></a> are a critical concept to modern code deployment workflows.  Deployment workflows operate in stages, where code is tested in an earlier stage and eventually promoted to a production environment in the final stage. An environment represents the infrastructure needed for one stage of a code deployment. Each environment should be a close replica of the production infrastructure to have parity. Earlier-stage environments should be used for testing changes. This concept applies to any code update, including routine updates to community-sponsored projects or new projects created for new features in your <span class="No-Break">Drupal application.</span></p>
			<p>Drupal applications have common deployment approaches and stages. It is common for Drupal developers to harness their local systems to perform initial code updates and high-level testing. Code is then deployed into environments accessible via the web by non-developers. Many Drupal applications harness development, stage, and production (dev, stage, prod) stages within a deployment workflow. This model affords effective single-stream development, meaning one change increment can be tested at a time and promoted through dev, stage, and prod environments. Dev, stage, and prod represent static environments where various stakeholders test changes as they get promoted. It is common for a quality assurance team to test in dev and a business team to test in stage. Prod should only be promoted after rigorous testing. However, single-stream development models are losing favor to multi-stream <a id="_idIndexMarker101"></a>models made popular by <strong class="bold">continuous integration/continuous delivery</strong> (<strong class="bold">CI/CD</strong>). This model creates an environment for every change. Each change gets promoted into one static staging environment for stakeholder validation and is then more rapidly deployed to production. This workflow can be faster, enables concurrent development across one or more developer/development teams, and does not package a series of changes that dev, stage, or prod testing may demand if multiple changes are being worked on at <span class="No-Break">a time.</span></p>
			<p>Drupal is not just code. As mentioned in <a href="B19491_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, Drupal maintains code, a database, and a filesystem, where configuration is often stored in code and the state resides in the database. Deployment should be viewed as a point in time that maps specific code, a specific database backup, and a specific archive of the filesystem. Performing any stage-based development workflow needs to observe a <em class="italic">code up, content down </em>promotion model. Code is promoted from earlier-stage environments up to production. However, production is <em class="italic">the source of truth</em> for Drupal’s persistent content. A snapshot of the content found in the production database and filesystem should be created at the point at which a deployment occurs and then be staged down to the environment where the code deployment happens. This ensures the deployed environment has the most up-to-date state of production to effectively perform testing. A stale database and files in an environment may not allow effective testing or help mirror a <a id="_idIndexMarker102"></a>production deployment. As such, code is promoted up through stages to production, and content is pushed down in stages from production. It is best practice to do this for <span class="No-Break">each deployment.</span></p>
			<p>The following figure demonstrates a code deployment workflow with dev, stage, and prod environments with a <em class="italic">code up, content </em><span class="No-Break"><em class="italic">down</em></span><span class="No-Break"> model:</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B19491_03_4.jpg" alt="Figure 3.4 – Drupal code deployment workflow with environments" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Drupal code deployment workflow with environments</p>
			<p>Given Drupal’s extensibility <a id="_idIndexMarker103"></a>and the freedom afforded to open-source maintainers, it cannot be assumed that pulling updated code from the community can be done simply and without issue. Custom projects that harness Drupal’s APIs do not have the benefit of engagement from the broader open-source community. Some level of testing needs to be in place, and it is ideal for this testing to occur before the code is launched into a production environment. The best Drupal applications harness automated testing to ensure there is effective continuity for updating code. The importance of small deployments done frequently cannot be overstated. A small deployment makes it far easier to isolate issues and ensure that there is less code to roll back until the issue is addressed. Given that core and contributed projects are open source, any issue should be reported back to the <span class="No-Break">respective project.</span></p>
			<p>Administrators need to be prepared for something to go wrong, even with well-tested code deployments. At the time of a production deployment, a backup needs to be created for the database and file assets. Ideally, code should be managed in a code versioning system. All <strong class="source-inline">Drupal.org</strong> projects use Git, as Git has become a well-adopted community standard for code versioning. Git has built-in revisioning with its commit log. Rolling back code on a failed deployment is as simple as checking out an earlier commit.  It is important to not store logs in the database (Drupal’s <strong class="source-inline">dblog</strong> module), as this can cause the size of your database to grow significantly. Any <a id="_idIndexMarker104"></a>restoration would also both take longer and lose log data between the backup and restoration. The restoration process should involve loading the SQL, loading the file archive, and reverting to the last commit. Please note that restoration is a destructive operation and should be used as a last resort, as any content or file assets created between the code deployment and restoration will be lost. A failed release should be identified and restored as soon as possible to avoid loss of data. Leveraging tags in a code repository per release can ensure that you can more easily see what was released <span class="No-Break">and when.</span></p>
			<p>The code that gets <a id="_idIndexMarker105"></a>deployed must be a fully built code artifact. Given that Drupal uses Composer, it is common for a code repo to contain custom code and the packaging metadata to assemble the code. This packaging definition is stored in a <strong class="source-inline">composer.json</strong> file, which defines the version of Drupal core and the projects with their desired installed versions from <strong class="source-inline">drupal.org</strong>. Each Composer update modifies the <strong class="source-inline">composer.lock</strong> file, which should also be versioned. The code assembly can happen on a server after the code is updated, but it is extremely important to load code from a specific, tested deployment defined in <strong class="source-inline">composer.lock</strong> and not install the code from <strong class="source-inline">composer.json</strong> directly. Many Drupal themes also generate frontend code using tools such<a id="_idIndexMarker106"></a> as <strong class="bold">npm</strong>. A fully built code base needs to load both backend and <span class="No-Break">frontend code.</span></p>
			<p>Once the new code is deployed, a few steps need to be executed to load the changes. First, the database schema needs to be updated. Second, the configuration needs to be loaded, as this is often maintained with code within the Git repository. Third, Drupal’s cache needs to be cleared. It is common to see both updates and deployments automated with Drupal’s command-line tool, Drush. More advanced DevOps and automation are shared in <a href="B19491_17.xhtml#_idTextAnchor476"><span class="No-Break"><em class="italic">Chapter 17</em></span></a>, <em class="italic">Git, Drush, Composer, CLI, </em><span class="No-Break"><em class="italic">and DevOps</em></span><span class="No-Break">.</span></p>
			<p>Maintaining and operating<a id="_idIndexMarker107"></a> Drupal is critical to keeping the application running, effectively loading updates, keeping your application secure, and having practices that enable testing and predictability. Understanding tools such as Composer, Git, and Drush is a core skill that any Drupal developer needs. Harnessing concepts such as environments and automation in deployment workflows helps promote consistency in the process and ensures that the web server, database, and files <a id="_idTextAnchor082"></a>respect Drupal’s code and <span class="No-Break">content differences.</span></p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor083"></a>Summary</h1>
			<p>In this chapter, we covered aspects of Drupal’s high-level architecture, including its backend application and its frontend presentation layer. The three main components of Drupal, code, files, and the database, were highlighted. Various hosting platform requirements were defined and high-level deployment strategies were shared, covering each of the three main components. Finally, the chapter explained maintenance considerations regarding Drupal architecture to help you effectively run Drupal applications. The next chapter will explore the <span class="No-Break">Drupal community.</span></p>
		</div>
	</body>
</html>
