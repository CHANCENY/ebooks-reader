<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" xmlns:epub="http://www.idpf.org/2007/ops">
	<head>
		<title>B19491_10</title>
		<link href="css/style-JRserifv6.css" rel="stylesheet" type="text/css" />
	</head>
	<body id="B19491_10">
		<div id="_idContainer066">
			<h1 id="_idParaDest-160" class="chapter-number"><a id="_idTextAnchor293"></a>10</h1>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor294"></a>Drupal Views <br />and Display Modes<a id="_idTextAnchor295"></a></h1>
			<p><a id="_idTextAnchor296"></a>Drupal has a feature called Views that helps deliver dynamic content displays. This is one of the more popular features of Drupal, as it allows site builders to take existing structured content and reuse it in additional ways. This helps content authors avoid duplicating the same content that may be delivered in multiple places throughout a Drupal application. This chapter helps define Views, covers its features, and walks through how to use the feature. The chapter also touches on a complementary feature called display modes, integrated with Views. The combination of these two features empowers site builders to address a large number of use cases with little or no code. While complex, the chapter will address the purpose, offer hands-on development with these features, and provide the foundation to build more advanced <span class="No-Break">use cases.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Defining Views</span></li>
				<li>Defining <span class="No-Break">display modes</span></li>
				<li>Using Views and <span class="No-Break">display modes</span></li>
			</ul>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor297"></a>Defining Views</h1>
			<p>Views, as a <a id="_idIndexMarker346"></a>feature, is one of the most compelling and most complex features for site builders. It is in core, which means it is out of the box with Drupal. At a high level, it is a dynamic display builder. Being able to learn and leverage its features effectively is not easy, but the results can <span class="No-Break">be empowering.</span><a id="_idTextAnchor298"></a></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor299"></a>Overview</h2>
			<p>Defining <a id="_idIndexMarker347"></a>Views is tricky. It is important to dissect this definition <span class="No-Break">significantly more.</span></p>
			<p>The term <em class="italic">display</em> in this context has a broad definition. Drupal maintains structured content, which can be used <a id="_idIndexMarker348"></a>within any display. In a traditional sense, <strong class="bold">content management systems</strong> (<strong class="bold">CMSs</strong>) store content that then gets displayed like a page on a website. Even Drupal does this with content types, nodes, and rendering nodes. However, recall earlier chapters where the problem of content duplication could be addressed by CMSs in favor of copying the same content repeatedly and pushing the burden onto content managers to do a lot of manual work. At a high level, a display could be<a id="_idIndexMarker349"></a> defined by any place content is served, with a desire to create multiple displays of the same content over duplication. So, by definition, a display extends well beyond a <span class="No-Break">typical page.</span></p>
			<p>The term <em class="italic">dynamic</em> is important as well. There is an implied relationship between the content and its displays. If the content can change, the display should also change. Drupal manages this relationship, and it handles the dynamic nature of <span class="No-Break">a display.</span></p>
			<p>Bringing this together, a dynamic display builder is a tool that allows site builders to create displays for Drupal’s content. A site builder configures the display and Drupal handles the rest. Drupal integrates the display with its native request and rendering capabilities. It handles content updates, which automatically update the related displays. Content authors gain the benefit of managing content in one place but reusing it where they expect the same content through <span class="No-Break">their application.</span></p>
			<p>Another <a id="_idIndexMarker350"></a>useful analogy is a <strong class="bold">database management system</strong> (<strong class="bold">DBMS</strong>). If we consider Drupal to handle the structure and storage of its content, the display of the content is one form of data retrieval. Views is one of those forms and solves similar problems to SQL. While SQL is transactional, some statements support retrieving information. Given DBMS often stores structured data, SQL helps specify fields from tables, relationships, filters, and even functions that transform the returned rows.  Views do this for Drupal data and <span class="No-Break">without c<a id="_idTextAnchor300"></a>ode.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor301"></a>Views features</h2>
			<p>Views <a id="_idIndexMarker351"></a>are intended to address many use cases around dynamic displays. To do so, Views has a large number of capabilities and configurations that can help a site builder create what <span class="No-Break">they need.</span></p>
			<p>At a high level, Views starts with a display and incorporates the following <span class="No-Break">high-level features:</span></p>
			<ol>
				<li>Selecting entity types for <span class="No-Break">the display</span></li>
				<li>Filtering and sorting by fields <span class="No-Break">or bundles</span></li>
				<li>Incorporating different types of displays (pages, blocks, view modes, field-based <span class="No-Break">displays, feeds)</span></li>
				<li>Managing the display settings and formatting of fields <span class="No-Break">and/or content</span></li>
				<li>Static content through header, footer, no results messaging, <span class="No-Break">and more</span></li>
				<li>Incorporation of linked, relational data <span class="No-Break">across entities</span></li>
				<li>Various APIs to customize Views behaviors <span class="No-Break">through modules</span></li>
			</ol>
			<p>It starts <a id="_idIndexMarker352"></a>with enabling site builders to manage Views. The Views UI is a separate module and one that needs to be enabled to provide the backend configuration screens for Views. A user will then be able to log in to Drupal’s backend and access the interface to manage Views, given the <span class="No-Break">correct permission.</span></p>
			<p>A View is a wrapper around one or more displays. A View has basic metadata, such as the name and description of the View. It is also possible to restrict access through permissions. The same View can have one or more displays, often designed to address similar displays that may have minor variations across <span class="No-Break">use cases.</span></p>
			<p>Creating a new View starts with a default display. The default display has a full definition for the display, which can be subsequently copied and overridden for similar displays within the View. The definition covers all of the configurations of Views features for a specific Views display. Subsequent displays inherit the configuration from the default and only specify changes relevant to the <span class="No-Break">secondary display.</span></p>
			<p>Given the broad definition of a display, a View starts with a display type. This integrates with other Drupal displays by offering a page (similar to rendering a node), a block that can be placed on a page, or even web services such as RSS feeds, XML, <span class="No-Break">and more.</span></p>
			<p>Each display type has options relevant to that display. Given that Views is in core and well integrated with other features of Drupal, it is common for display types to be able to be configured with similar capabilities.  For instance, a page display has a path, but a block display leverages Drupal’s native block placement, so it does not have a path. Block displays maintain the metadata of the block, such as <span class="No-Break">the title.</span></p>
			<p>Each display integrates with Drupal’s structured data by selecting the relevant entity type and fields. Selecting the entity type allows for the specific selection of fields to display. Every field type has its own different ways to configure the display. As an example, you can pick the relevant format for displaying date fields, such as “10/20/2023” or “October 20, 2023”. Images can select the specific <span class="No-Break">image style.</span></p>
			<p>Beyond formats, Views <a id="_idIndexMarker353"></a>also has some transformation capabilities relevant to the field type. A title can be converted into a link to that node. A body can be truncated and summarized to provide visitors with a glimpse into the content on a page. A Boolean field can be transformed into more descriptive information, such as on/off, yes/no, or selected/unselected for the specific use case. While this is not exhaustive, it is reasonable to expect additional, common transformations found for the type of field within <span class="No-Break">the display.</span></p>
			<p>Views also has support for relationships where one field references another entity. By creating a relationship, all fields of the related entity can then be used within Views. Again, one of the most important aspects of normalized data is the avoidance of repeated information. Using relationships in Drupal stores the data in one place, and relationship fields allow an entity to reference another entity. Suppose a display has the first and last name of an author (a user entity) from a listing of blog posts (nodes from a content type). By selecting the content type of <strong class="source-inline">blog post</strong> and adding a relationship to the <strong class="source-inline">user</strong>, Views can subsequently pull the first and last name fields from the <span class="No-Break">user profile.</span></p>
			<p>Filters are another useful feature that allows for a display to refine the entities returned. As an example, suppose a blog has a relationship field to a taxonomy called a <strong class="source-inline">category</strong><em class="italic"> </em>that identifies a blog post by subject matter. A display can filter blog posts by the subject matter, such as <strong class="source-inline">sports</strong> or <strong class="source-inline">politics</strong>. Using this feature allows various displays to more explicitly define what content <span class="No-Break">is needed.</span></p>
			<p>Views also have support for context through contextual filters. Context can be a broad and nuanced topic and one that expands well beyond Views. There are several common types of context, such as the date or time of a request, a user that is logged in (or anonymous), parameters that may be passed through a request, or a language passed through a browser in the request header. Natively, Views can filter displays based on the context. Showing blog posts that a user has authored is possible with a contextual filter of blog posts that uses the user authenticated at the time <span class="No-Break">of request.</span></p>
			<p>Exposed filters are another useful feature. A filter does not simply need to be through the definition and configuration of a View display. An exposed filter allows for a display to expose one or more filterable options within the display. This allows those who access the display to see a full list and subsequently pare down by specific field values at their discretion. To extend the blog post example, a View can show all categories but have an exposed filter that allows a user to filter down the results of the View by the category they are <span class="No-Break">interested in.</span></p>
			<p>Several other<a id="_idIndexMarker354"></a> features exist in Views that expand on the functionality mentioned in this chapter. It is useful to get hands-on with Views and explore it in greater depth, as it is a fairly <span class="No-Break">complex <a id="_idTextAnchor302"></a>feature.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor303"></a>Customizing Views</h2>
			<p>Views have<a id="_idIndexMarker355"></a> several typical means of customization, the most popular of which is through contributed modules. Through the community, one can find extended display types such as calendars, trees, accordions, or integrations with popular JavaScript libraries. More functional capabilities with Views can be added through <strong class="bold">Views Bulk Operations</strong> (<strong class="bold">VBO</strong>) or<a id="_idIndexMarker356"></a> data exports. It is useful to explore the Views category of projects to <span class="No-Break">learn more.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">One of the most important aspects of developing a Drupal application is effectively finding and adopting contributed modules before considering custom code. Views, in particular, has a robust set of contributed modules that already address a large number of use cases. Views are well integrated with other contributed modules such as field types, entity types, <span class="No-Break">and more.</span></p>
			<p>While Views is largely aimed at helping site builders avoid code, it can be common to override Views templates within custom themes. Views expose a naming convention and various types of templates, which allows a custom theme to provide its own Twig templates to override Views default markup. It is recommended to explore all site-building options before creating <span class="No-Break">custom code.</span></p>
			<p>Also, Views has a fairly robust framework for backend developers to create custom modules that extend the out-of-the-box capabilities. This can often help for advanced use cases where third-party data needs to be interfaced with Views or there is a need to filter the data provided to Views with advanced business logic not possible with site building. Views provide various APIs that allow a custom module to extend it <span class="No-Break">in code.</span></p>
			<p>Views is a complex but useful feature of Drupal core that helps create dynamic displays. It is well connected to the rest of Drupal, with entities, fields, blocks, themes, and more. Views’ ability to work with context, provide filters, and transform data helps address important use cases for displays without <span class="No-Break">touc<a id="_idTextAnchor304"></a>hing code.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor305"></a>Defining display modes</h1>
			<p>Drupal’s display <a id="_idIndexMarker357"></a>modes feature takes a different approach to creating displays and is complementary to Views. Conventionally, this feature starts with being able to control display settings for a content-type rendering on a page. However, additional display modes can be configured to display the same content in different ways <a id="_idTextAnchor306"></a><span class="No-Break">as needed.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor307"></a>Overview</h2>
			<p>Display modes<a id="_idIndexMarker358"></a> look at displays tied to a content type. A content type defines structured content. The same node within a content type can be displayed in different ways. Each display may be able to fine-tune which fields are displayed, labels, formats of field values, ordering of fields, and more. A content type can have as many display modes as needed to address any desired use case. Each content type can select a default display mode, which is most commonly used for <span class="No-Break">rendering nodes.</span></p>
			<p>This may be confusing concerning Views, given Views also allows for the building of displays. Display modes only define displays for content types. To create a display, a display mode must integrate with another Drupal feature. Also, display modes are used more broadly than just Views such as rendering nodes, providing display capabilities for nodes in blocks, and displaying nodes in Layout Builder. Views is a far more robust display system that can work across content types, against several display formats, <span class="No-Break">and more.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Given display modes can help create displays, it may not be required to leverage Views to build a display. Display modes are more lightweight, integrated throughout Drupal core display features, and help configure displays specific to a content type. If a display matches these criteria, use <span class="No-Break">display modes.</span></p>
			<p>Views do have native support for display modes. This saves time by allowing for the use of existing <a id="_idIndexMarker359"></a>display configurations tied to a content type. In favor of selecting specific fields in a content type, a site builder can harness all of Views’ features but simply select a full entity and a corresponding display mode. And, in the case of entity references found in fields, Views allows for selecting a display mode in addition to field selection of the <span class="No-Break">referenced entity.</span></p>
			<p>Display modes are also integrated into Drupal’s theming system. While the feature helps site builders rapidly configure displays for a content type, a display mode still may need to be customized visually. Thankfully, display modes have corresponding templates that allow a developer to enhance a Drupal theme to modify the ma<a id="_idTextAnchor308"></a>rkup <span class="No-Break">or CSS.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor309"></a>Popular use cases</h2>
			<p>Display modes can be leveraged in several common <span class="No-Break">use cases:</span></p>
			<ul>
				<li><strong class="bold">Node-based default displays</strong>: A <a id="_idIndexMarker360"></a>display mode allows for flexibility to configure<a id="_idIndexMarker361"></a> node-based displays across several use cases. A key benefit of Drupal is the ability to reuse the same content as needed across several displays. However, it’s not assumed each display is the same. A display mode allows a site builder to create any number of displays for the same content type and node based on any desired use cases and variations. A variation may be as simple as not showing the authoring information of a node in one part of the Drupal application if the default node display shows the author information. It may also involve tweaking an image to show a thumbnail and not a fully rendered image only on the home page or within a specific <span class="No-Break">View listing.</span></li>
				<li><strong class="bold">Teasers</strong>: One of the <a id="_idIndexMarker362"></a>most popular use cases for display modes is known as a teaser. Typically, a default display mode is a full representation of the visible fields of a node. A teaser is intended to introduce or summarize the same content, often so that one can click on the teaser to view the full details. The same idea can be extended to a display mode where a node is featured and the content is more prominent than other displays. The Umami demo distribution leverages a teaser display mode for its home <span class="No-Break">page listing.</span></li>
			</ul>
			<p>Display modes help configure displays, similar to Views, but are more directly tied to variations in displaying nodes’ content types. Features for display modes can be used in Views but also other Drupal features. Using display modes helps address common use cases such as teasers and features that use the same underlying content as <span class="No-Break">f<a id="_idTextAnchor310"></a>ull-page views.</span></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor311"></a>Using Views and display modes</h1>
			<p>Using Views<a id="_idIndexMarker363"></a> is one of the more difficult tasks for site builders given its vast configuration options. While this chapter affords hands-on options, it is important to explore the feature in greater depth and to get more practice <span class="No-Break">with time.</span></p>
			<p>All the following examples leverage a blog content type with a primary use case of building different blog-related displays in the Drupal application. For the sake of clarity, the content type has fields for title, body, featured, and a banner image. Also, it’s assumed the Views UI module is enabled for the next screenshots and that a user is logged in with the <span class="No-Break">corr<a id="_idTextAnchor312"></a>ect permissions.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor313"></a>Creating a teaser display mode for blogs</h2>
			<p>An<a id="_idIndexMarker364"></a> effective teaser could be as simple <a id="_idIndexMarker365"></a>as a title of the blog linked to the full page with some preliminary, summarized <span class="No-Break">body content.</span></p>
			<p>Follow these instructions to create <span class="No-Break">a teaser:</span></p>
			<ol>
				<li>A teaser display mode can be created by going to <strong class="bold">Administration</strong> | <strong class="bold">Structure</strong> | <strong class="bold">Display modes</strong> | <strong class="bold">View</strong> and pressing <strong class="bold">Add new Content view mode</strong>. This prompts a simple form to enter the name of the display mode. This enables the display mode for all content types, which can now be configured for the blog <span class="No-Break">content type.</span></li>
				<li>On the content type listing page, found at <strong class="bold">Administration</strong> | <strong class="bold">Structure</strong> | <strong class="bold">Types</strong>, the blog content type will have a drop-down list of options. Selecting <strong class="bold">Manage Display</strong> allows a site builder to manage its display mode configuration. At the bottom of the page, the following screenshot shows <strong class="bold">Custom display settings</strong>, which are used to enable or disable specific display modes for each <span class="No-Break">content type:</span></li>
			</ol>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B19491_10_1.jpg" alt="Figure 10.1 – Custom display settings for content types" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Custom display settings for content types</p>
			<ol>
				<li value="3">After <a id="_idIndexMarker366"></a>creating the new <a id="_idIndexMarker367"></a>display mode, the display mode must then be enabled for the content type you wish to leverage. The <strong class="bold">Teaser</strong> checkbox is selected in the preceding screenshot, signifying that the blog content type has the teaser display <span class="No-Break">mode enabled.</span></li>
				<li>Once the display mode is enabled, a tab will exist at the top of the blog’s <strong class="bold">Manage display</strong> page for the specific display mode. The following screenshot shows the blog with <span class="No-Break">teaser enabled:</span></li>
			</ol>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B19491_10_2.jpg" alt="Figure 10.2 – Managing display modes for a content type" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Managing display modes for a content type</p>
			<ol>
				<li value="5">After<a id="_idIndexMarker368"></a> clicking on the <strong class="bold">Teaser</strong> tab, this page allows for several different configurations for display modes. First, the order of the fields displayed can be modified by dragging the far-left <a id="_idIndexMarker369"></a>toggle up or down. Dragging the toggle into <strong class="bold">Disabled</strong> removes the field from the display mode. For the specific teaser use case, the featured checkbox and links have been moved to <strong class="bold">Disabled</strong>. The second column demonstrates the label. This allows a site builder to select whether or not the field label is displayed in the display mode. The <strong class="bold">Format</strong> column provides different ways to render the field depending on the field type. Given the body field is to be summarized, the format for that field is set to <strong class="bold">Summary or trimmed</strong> for our <span class="No-Break">use case.</span></li>
			</ol>
			<p>This effectively creates our teaser display mode for the blog content type. Additional rendering options exist for each field display by pressing the gear icon on the f<a id="_idTextAnchor314"></a>ar right of <span class="No-Break">each row.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor315"></a>Creating a View for a blog listing – option 1 with teaser display mode</h2>
			<p>Now that the blog<a id="_idIndexMarker370"></a> content type has a teaser display, a View can be created that harnesses the display mode for a blog listing. Start by going to <strong class="bold">Administration</strong> | <strong class="bold">Structure</strong> | <strong class="bold">Views</strong> and pressing the <strong class="bold">Add View</strong> button. This prompts an initial configuration form to create the View, as found in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B19491_10_3.jpg" alt="Figure 10.3 – Initial View creation form" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Initial View creation form</p>
			<p>This form prompts for the basic metadata of the View and its initial configuration. The name and description help provide the purpose of the View. The <strong class="bold">View settings</strong> option helps define the high-level display logic. For the use case of a blog listing, selecting a <strong class="bold">Content</strong> option of type <strong class="bold">Blog</strong> will get the correct content type, with an option to provide the sorting logic. Finally, the ability to add two initial displays to the View exists by checking <a id="_idIndexMarker371"></a>boxes for creating a page or creating a block. For the sake of demonstration, a block display was selected to be able to place the same block on multiple pages. The following screenshot immediately prompted more options for the <span class="No-Break">block display:</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B19491_10_4.jpg" alt="Figure 10.4 – Displaying specific settings for display modes on the initial View creation" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Displaying specific settings for display modes on the initial View creation</p>
			<p>This form allows us to configure specific settings of the block display. For the block title, a <strong class="bold">Blog teaser listing</strong> helps effectively identify the purpose of the block. The <strong class="bold">Display format</strong> selection provides various display options for the block, such as list, grid, and table, all of which have various additional and specific configurations. The second dropdown helps identify what to display and has options for a default linked title, the ability to specify fields or a selection of the display mode for the blog. In this case, <strong class="bold">Teaser</strong> is selected for the dropdown. Finally, the block supports a specific number in the list with the ability to paginate. This can be enabled based on the specific use case. By pressing <strong class="bold">Save and edit</strong>, the View is effectively created and has the basic configuration of our blog listing with te<a id="_idTextAnchor316"></a>aser <span class="No-Break">display modes.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor317"></a>Creating a View for a blog listing – option 2 with fields</h2>
			<p>One of the <a id="_idIndexMarker372"></a>most common use cases for Views is to use fields within the structured content of an entity. The previous example bypassed Views’ field capabilities by harnessing the display mode for the blog content type. This second option produces a similar listing but with fields <span class="No-Break">within Views.</span></p>
			<p>Start a new View, again, by going to <strong class="bold">Administration</strong> | <strong class="bold">Structure</strong> | <strong class="bold">Views</strong> and pressing the <strong class="bold">Add View</strong> button. The following screenshot demonstrates the form to add <span class="No-Break">this View:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B19491_10_5.jpg" alt="Figure 10.5 – Displaying specific settings for fields on the initial View creation" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Displaying specific settings for fields on the initial View creation</p>
			<p>The <a id="_idIndexMarker373"></a>preceding screenshot shows most of the same settings by selecting content and picking the blog content type. The notable difference is in the block display settings, where <strong class="bold">fields</strong> is selected instead of the display mode in the previous example. After saving, the initial View is created but still <span class="No-Break">requires configuration.</span></p>
			<p>The next screenshot demonstrates the Views configuration interface for <span class="No-Break">each View:</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B19491_10_6.jpg" alt="Figure 10.6 – Interface for editing the configuration of a View" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Interface for editing the configuration of a View</p>
			<p>To finish <a id="_idIndexMarker374"></a>the previous example, the View needs to be configured with the specific fields for the teaser. By default, the View has the title field that is linked to the node. To build the teaser, both the banner image field and the summary of the body field need to be added to the View. In the <strong class="bold">Fields</strong> section, press <strong class="bold">Add</strong>, search for <strong class="source-inline">body</strong>, check the box, and press <strong class="bold">Add and configure fields</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B19491_10_7(Merged).jpg" alt="Figure 10.7 – The two steps for adding a new field into a View" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – The two steps for adding a new field into a View</p>
			<p>The second step, also <a id="_idIndexMarker375"></a>shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.7</em>, prompts a screen to configure the settings for the body field. This includes a label, a formatter, and four different sections of various settings. Each of the four sections contains several helpful features that address common use cases, but the options change per field type, and there is a significant amount of depth in each section that would be difficult to summarize comprehensively in this chapter. For our specific use case, select <strong class="bold">Summary or trimmed</strong> for the formatter of the body field with a desired character count to effectively summarize the content. After clicking the <strong class="bold">Apply</strong> button, the field is added to <span class="No-Break">the View.</span></p>
			<p>For the sake of brevity, the same process that added the body field can be used to add a banner image to the View. Different configuration options will be prompted for an image field that would be different from the field type of the <span class="No-Break">body field.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Every time a View is edited through the interface, it is not automatically saved. It stages any changes, and the changes only take effect once the <strong class="bold">Save</strong> button is pressed. It is important not to forget to save; otherwise, the View may continue to show the <a id="_idTextAnchor318"></a><span class="No-Break">older configuration.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor319"></a>Explaining the Views editing interface</h2>
			<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.6</em> demonstrates the<a id="_idIndexMarker376"></a> Views editing interface, which is full of useful features. While it is not possible to more comprehensively cover these features due to nuances with field types and the breadth of configuration options, it is still helpful to have an overview of each section with relevant <span class="No-Break">use cases.</span></p>
			<p>The top row helps manage the displays for the View and the operations for <span class="No-Break">the View:</span></p>
			<ul>
				<li><strong class="bold">Displays</strong>: The top row of blocks is each of the displays in the View. The display currently being edited will be highlighted in a different color. The <strong class="bold">+Add</strong> button allows for the creation of secondary displays in the <span class="No-Break">same View.</span></li>
				<li>The dropdown on the right of the top bar allows for editing the metadata of the View, duplicating the View, reordering displays, or deleting <span class="No-Break">the View.</span></li>
			</ul>
			<p>Under the top row is the preliminary display type configuration and a dropdown for the operations of the display. This is useful for changing the display type or for operations such as duplicating <span class="No-Break">the display.</span></p>
			<p>The first column defines the content configuration of the <span class="No-Break">highlighted display:</span></p>
			<ul>
				<li><strong class="bold">Title</strong>: This is the title of the display, which is typically <strong class="bold">Metadata</strong> and can be optionally included in <span class="No-Break">the display.</span></li>
				<li><strong class="bold">Format</strong>: This configuration helps define how the View gets displayed and the settings for that display format. It also provides the configuration for what gets displayed in the View, which is the selection of fields or a specific display mode. And, depending on what is selected, there are <span class="No-Break">specific settings.</span></li>
				<li><strong class="bold">Filter criteria</strong>: Just as with querying a database, one or more criteria can be provided to filter the results. In our example of blogs, only published nodes with the blog content type are displayed. <strong class="bold">Published</strong> is a specific setting of the node and is one filter. The blog content type is a second filter. Those criteria ensure only the correct subset of all nodes is returned. Additional criteria can be added based on the <span class="No-Break">use case.</span></li>
				<li><strong class="bold">Sort criteria</strong>: A View can be configured to return results in a specified order. Common use cases are alphabetical by title, by the date published, <span class="No-Break">and more.</span></li>
			</ul>
			<p>The middle<a id="_idIndexMarker377"></a> column manages the configuration for how the content <span class="No-Break">is displayed:</span></p>
			<ul>
				<li><strong class="bold">Block settings</strong>: This was the specific display type of the example display, but this section generally shows the configuration tied to the display type. This configuration changes by <span class="No-Break">display type.</span></li>
				<li><strong class="bold">Permission</strong>: Most display types allow for configuring permission that can perform access control to <span class="No-Break">the display.</span></li>
				<li><strong class="bold">Header and Footer</strong>: Static content that is delivered before and after the results of the content <span class="No-Break">display, respectively.</span></li>
				<li><strong class="bold">No results behavior</strong>: Different behaviors can happen if no content exists in the display. Some simple examples would be returning nothing or static text if no content <span class="No-Break">is found.</span></li>
				<li><strong class="bold">Pager</strong>: Displays that have a large amount of content often need to be able to support pagination. The <strong class="bold">Pager</strong> section allows for configuring the amount of content returned and the controls <span class="No-Break">to paginate.</span></li>
			</ul>
			<p>The third column has advanced settings for displays that expand beyond <span class="No-Break">basic capabilities:</span></p>
			<ul>
				<li><strong class="bold">Relationships</strong>: This provides the ability to use entity relationships within Views. The most common use case is an entity type that has a relationship field to another entity where the View contains information from the <span class="No-Break">other entity.</span></li>
				<li><strong class="bold">Contextual filters</strong>: The ability to filter content based on context, as described previously. This is useful to provide filters created from other Drupal features, such as the user logged in, information from the request, desired language, <span class="No-Break">and more.</span></li>
				<li><strong class="bold">Exposed form</strong>: A capability to allow a user to control filters when viewing <span class="No-Break">a display.</span></li>
				<li><strong class="bold">Other</strong>: There are several ad hoc behaviors or configurations that can be adjusted for the display, such as caching, administrative metadata, or custom <span class="No-Break">CSS classes.</span></li>
			</ul>
			<p>Countless<a id="_idIndexMarker378"></a> other more detailed use cases can stem from some of the high-level use c<a id="_idTextAnchor320"></a>ases <span class="No-Break">defined previously.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor321"></a>Creating an RSS feed display</h2>
			<p>Displays<a id="_idIndexMarker379"></a> in Views do not just apply to content rendered <a id="_idIndexMarker380"></a>by Drupal through a page or a block. Common web service APIs allow for displays in Views to become a feed for machine-driven content delivery. A common use case is an <span class="No-Break">RSS feed.</span></p>
			<p>Following the aforementioned steps of adding a View without adding a page or a block creates a default display of blog nodes. A feed can be added by pressing the <strong class="bold">+Add</strong> button, which prompts a dropdown of different display types, as exemplified in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B19491_10_8_Merged.jpg" alt="Figure 10.8 – The dropdown for adding a display to a View, resulting format, and settings" />
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – The dropdown for adding a display to a View, resulting format, and settings</p>
			<p>By selecting <strong class="bold">Feed</strong>, a display is created from the existing configuration set when adding the View. The format, by default, is set to <strong class="bold">RSS Feed</strong>, and the display type settings change to <strong class="bold">Feed settings</strong> where a path to the feed can <span class="No-Break">be set.</span></p>
			<p>Views can address many nuanced use cases, all rooted in creating dynamic displays that are well-integrated throughout Drupal. Site builders are then given the tools and discretion to configure Views based on the desired use cas<a id="_idTextAnchor322"></a>es of <span class="No-Break">the application.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor323"></a>Summary</h1>
			<p>Views help provide a robust, feature-rich dynamic display tool for site builders. Its ability to configure features across different types of displays, structured content, and other Drupal features helps Views reuse the same content in different displays and feed-based formats. Display modes help complement Views for displays directly integrated with content types. The combination of both offers two highly flexible tools capable of addressing a large number of <span class="No-Break">use cases.</span></p>
			<p>The next chapter presents media and files that help Drupal manage and deliver static <span class="No-Break">digital assets.</span></p>
		</div>
	</body>
</html>
